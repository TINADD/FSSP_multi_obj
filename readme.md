**<u>NSGAII算法思路:</u>**

对每个粒子进行局部搜索（first improve）一定代数

通过遗传交叉产生子代种群

合并当前种群和子代种群，并选出前pops个最优粒子作为当前种群，继续......



**<u>HPSO算法思路：</u>**

更新位置公式为了增加解的多样性，进行发散，不能使粒子的解变得更好。

局部搜索为了让解收敛，采取first improve的策略

1. 改进前操作过程  ，（效果不如NSGAII好）：

   对每个粒子都进行：更新位置+局部搜索

   隔一定代数进行扰动（这个扰动不能增加解的多样性，为了加快收敛速度，使解变得更优。）

   （扰动方式：~~1.对于每个粒子都从archive存档集里随机选一个，但这样不能提高收敛速度，因为获得的新解不能保证比之前的解更优，也就不符合加快收敛速度的思想。~~

   2. 每次扰动都给archive排序，更新前min(pops，archive.size())个粒子

局部搜索会出现TT不变，TEC每次只减小一点，也就是说每次局部搜素其实改变不大，甚至会不变（怎么会这样），重写比较函数<（< <= ||<= < 改成 < <=  或者改成 < <） ，大算例禁忌搜索深度不能太大，跑步出来

   2. 改造后

      每代都对每个粒子进行局部搜索，同时更新gbest pbest

      （更新策略：支配，接受；互不支配，以一定概率接受（0.1、））

      每隔一定代数进行扰动 （50、）

      每隔一定代数进行发散 （记录gbest上次更新处于的代数，如果（）代之内gbest没有被更新变优就发散）